# Category 0: The Android Framework

## 해당 챕터를 읽고 느낀점

이번 챕터는 꽤나 분량이 많았는데 생각보다 모르던 개념들이 많았던거 같다,,  
그나마 알고있던 부분들 중에서도 개발경험이랑 연결된 부분은 이해가 잘 되었는데, 단순하게 개념만 알고있던 부분은 확실히 이보단 쉽지 않았다.  
사실 처음에는 책 내용을 전부 이해할 수 있게 학습하려 했는데,, 욕심인거 같고 일단 1회차에는 가볍게 읽어보면서 지식을 넓히는 방향으로 가보려고 한다~

## 🙋🏻 Practical Questions (0 ~ 32)

### 0. Android란 무엇인가요?
> 🗣️ Q) Android 플랫폼 아키텍처는 Linux 커널, Android 런타임(ART), 하드웨어 추상화 계층(HAL) 등 여러 계층으로 구성되어 있습니다. 이 구성 요소들이 애플리케이션 실행과 하드웨어 상호작용을 어떻게 함께 보장하는지 설명해보세요.

### 1. 인텐트(Intent)란 무엇인가요?
> 🗣️ Q) 명시적 인텐트와 암시적 인텐트의 핵심 차이점은 무엇이며, 각각 어떤 상황에서 사용하나요?
 
핵심 차이점: 대상 컴포넌트를 명확히 지정하느냐의 여부  

**`명시적 인텐트(Explicit Intent)`:**  
실행할 컴포넌트의 클래스명을 명확히 지정한다.  
앱 내부의 특정 컴포넌트를 직접 호출하는 경우 사용한다.  

**`암시적 인텐트(Implicit Intent)`:**  
컴포넌트를 지정하지 않고, Action, Data type 을 기반으로 시스템이 적절한 컴포넌트를 찾아 실행한다.  
다른 앱의 기능을 호출하거나, 시스템에 특정 작업을 요청하는 경우 사용한다.

> 🗣️ Q) 안드로이드 시스템은 어떤 방식으로 암시적 인텐트를 처리할 앱을 결정하며, 적절한 앱이 없을 경우에는 어떻게 되나요?

매니페스트의 인텐트 필터를 통해 인텐트 처리할 앱을 결정한다. 적절한 앱이 없을 경우 `ActivityNotFoundException` 예외가 발생한다.

---

### 2. Pending Intent의 목적은 무엇인가요?
> 🗣️ Q) PendingIntent란 무엇이며, 일반 Intent와 어떤 차이가 있나요? PendingIntent가 반드시 필요한 상황의 예를 들어 설명해보세요.
 
**`PendingIntent`**:  
다른 애플리케이션이나 시스템 구성요소가 나중에, 당신의 애플리케이션을 대신하여 미리 정의된 Intent를 실행할 수 있도록 권한을 부여하는 특수한 형태의 Intent.  
일반 Intent는 즉시 실행되 현제 앱 내부에서만 사용이 가능하지만, PendingIntent는 나중에 실행가능 하며, 다른 앱이나 시스템이 대신 실행이 가능하다.  

**pendingIntent가 반드시 필요한 상황의 예시:**  
사용자가 알림(Notification)을 탭했을 때 특정 액티비티를 열고 싶다면, 알림 시스템은 앱이 꺼져 있어도 동작해야 하므로 PendingIntent를 통해 실행 정보를 넘겨야 한다.
```kotlin
val intent = Intent(this, MyActivity::class.java)
val pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE)

val notification = NotificationCompat.Builder(this, CHANNEL_ID)
    .setContentTitle("새 메시지")
    .setContentText("알림을 탭하면 열립니다.")
    .setContentIntent(pendingIntent)
    .build()
```
---

### 3. Serializable과 Parcelable의 차이점은 무엇인가요?
> 🗣️ Q) Android에서 Serializable과 Parcelable의 주요 차이점은 무엇이며, 컴포넌트 간 데이터 전달 시 일반적으로 Parcelable이 선호되는 이유는 무엇인가요?

**주요 차이점:**

| 항목         | Serializable                   | Parcelable                      |
|------------|--------------------------------|---------------------------------|
| **정의**     | Java 표준 인터페이스                  | Android 전용 인터페이스                |
| **작동 방식**  | 리플렉션(Reflection)을 기반으로 동작      | 수동으로 데이터를 읽고 쓰는 방식              |
| **성능**     | 느림 – 많은 임시 객체 생성, GC 부담 큼      | 빠름 – 불필요한 객체 생성 최소화             |
| **구현 난이도** | 매우 간단 (implements만 하면 됨)       | 비교적 복잡하지만 `@Parcelize`로 단순화 가능  |
| **사용 목적**  | 성능이 중요하지 않거나 비-Android 코드에서 사용 | Android IPC나 Activity 간 전달 시 사용 |
<br>

**선호 이유:**  
- 고성능: Parcelable은 Android 플랫폼에 최적화되어 있어 Serializable보다 훨씬 빠릅니다. 특히 대용량 데이터를 다룰 때 유리합니다.
- 메모리 효율성: 불필요한 객체 생성을 줄이고, GC 부담을 낮추는 방식으로 설계되어 있습니다.
- IPC 최적화: Android의 Binder 기반 IPC 통신에 최적화되어 있어, Activity, Service, BroadcastReceiver 간 데이터 전달 시 안정적이고 효율적입니다.
- @Parcelize 사용 가능: Kotlin에서는 kotlin-parcelize 플러그인을 통해 @Parcelize 애노테이션 하나로 Parcelable 구현을 자동 생성할 수 있어 구현 부담이 크게 줄었습니다.

---

### 4. Context란 무엇이며, 어떤 종류가 있나요?
> 🗣️ Q) 안드로이드 애플리케이션에서 올바른 타입의 Context를 사용하는 것이 왜 중요한가요? Activity Context를 장시간 참조할 경우 어떤 위험이 발생할 수 있나요?

Context를 올바르게 사용하면 효율적인 리소스 관리를 할 수 있으며, 메모리 누수나 앱 크래시를 방지할 수 있다. 따라서 상황에 맞는 Context를 선택하고, 불필요하게 보존하지 않는 것이 중요하다.

**Activity Context를 장시간 참조할 경우 발생할 수 있는 위험:**  
Activity Context는 해당 Activity의 생명주기에 종속되어 있다. 그런데 이 Context를 싱글톤 객체나 전역 변수로 저장해 두면, Activity가 종료된 후에도 GC(Garbage Collector)가 이를 회수하지 못해 메모리 누수(Memory Leak)가 발생한다.

---

### 5. Application 클래스란 무엇인가요?
> 🗣️ Q) Application 클래스의 목적은 무엇이며, 생명주기와 리소스 관리 측면에서 Activity와는 어떻게 다르나요?

목적:  
애플리케이션 전역에서 사용되는 리소스와 설정을 초기화하고 관리하는 것입니다.

다른점:  
Application 클래스는 전역 상태 및 리소스를 위한 중심점으로, 앱 전체에 걸쳐 한 번만 초기화되는 것이 특징이다.  
Activity는 화면 단위의 일시적인 컴포넌트로, 사용자 인터페이스에 직접 관여하며 수명 주기가 짧기 때문에 전역 리소스를 초기화하거나 관리하는 데 적합하지 않다.

---

### 6. AndroidManifest 파일의 목적은 무엇인가요?
> 🗣️ Q) 인텐트 필터가 AndroidManifest에서 앱 간 상호작용을 가능하게 하는 방식은 무엇이며, 액티비티 클래스가 AndroidManifest에 등록되지 않으면 어떤 일이 발생하나요?

인텐트 필터는 앱의 구성 요소(예: 액티비티, 서비스, 브로드캐스트 리시버)가 어떤 인텐트(Intent)에 응답할 수 있는지를 선언한다. 이를 통해 다른 앱이나 시스템이 해당 구성 요소를 호출하거나 데이터를 전달할 수 있다.  

액티비티 클래스가 AndroidManifest에 등록되지 않으면, Android 시스템은 해당 액티비티의 존재를 알지 못한다. 따라서 해당 액티비티를 실행하려고 하면 다음과 같은 런타임 오류가 발생힌다: `android.content.ActivityNotFoundException`

---

### 7. Activity 생명 주기를 설명하시오.
> 🗣️ Q) onPause()와 onStop()의 차이점은 무엇이며, 리소스를 많이 사용하는 작업은 어떤 메서드에서 처리하는 것이 좋을까요?

`onPause()`: 액티비티가 부분적으로 가려질 때 호출된다.  
`onStop()`: 액티비티가 완전히 화면에서 사라질 때 호출된다.

리소스 사용량이 많은 작업은 `onStop()`에서 처리하는 것이 적절하다.

---

### 8. Fragment 생명 주기를 설명하시오.
> 🗣️ Q) onCreateView()와 onDestroyView()의 목적은 무엇이며, 이 메서드들에서 뷰 관련 리소스를 적절히 처리하는 것이 왜 중요한가요?

onCreateView()의 목적: Fragment의 UI 레이아웃을 생성하는 역할을 한다.  
onDestroyView()의 목적: Fragment의 View 계층 구조가 제거되기 직전에 호출된다.  

**왜 적절한 리소스 처리가 중요한가?**
1. 메모리 누수 방지:  
View 객체에 대한 참조를 계속 유지하면, View가 파괴된 후에도 메모리가 해제되지 않아 누수가 발생할 수 있습니다.

2. 예외 및 오류 방지:  
onDestroyView() 이후에는 View가 존재하지 않기 때문에, 이 시점 이후에 View를 참조하면 NullPointerException 등의 예외가 발생할 수 있습니다.

3. 생명 주기 안전성:  
onCreateView()에서 생성된 리소스는 View의 생명 주기에 맞춰 해제되어야 하며, 이를 통해 Fragment 재사용성과 UI 일관성을 유지할 수 있습니다.

---

### 9. Service란 무엇인가요?
> 🗣️ Q) Android에서 Started Service와 Bound Service의 차이점은 무엇이며, 각각은 언제 사용하는 것이 좋을까요?

Started Service는 독립적이고 장시간 실행되는 작업에 적합하다  
Bound Service는 클라이언트와의 실시간 상호작용이 필요한 작업에 적합하다.

---

### 10. BroadcastReceiver란 무엇인가요?
> 🗣️ Q) 브로드캐스트의 종류에는 어떤 것들이 있으며, 시스템 브로드캐스트와 커스텀 브로드캐스트는 기능과 사용 측면에서 어떻게 다른가요?

브로드캐스트의 종류:  
시스템 브로드캐스트(System Broadcasts): 운영체제 주도의 이벤트에 대응할 때 유용하다.    
커스텀 브로드캐스트(Custom Broadcasts): 앱 내부 논리적 이벤트 처리에 적합합니다.

---

### 11. ContentProvider의 목적은 무엇이며, 애플리케이션 간의 안전한 데이터 공유를 어떻게 가능하게 하나요?
> 🗣️ Q) ContentProvider URI의 주요 구성 요소는 무엇이며, ContentResolver는 데이터를 조회하거나 수정하기 위해 ContentProvider와 어떻게 상호작용하나요?

**구성요소:**  
1. **Authority**: ContentProvider를 식별하는 문자열 (예: com.example.myapp.provider)
2. **Path**: 데이터의 유형을 지정 (예: /users 또는 /products)
3. **ID (선택 사항)**: 데이터셋 내의 특정 항목을 참조할 때 사용  
<br>

**ContentResolver는 ContentProvider와 데이터를 주고받기 위한 표준 API로, 다음과 같은 메서드를 통해 ContentProvider와 상호작용 한다**:  
- query(): 데이터를 조회합니다. (SELECT)
- insert(): 데이터를 삽입합니다. (INSERT)
- update(): 데이터를 수정합니다. (UPDATE)
- delete(): 데이터를 삭제합니다. (DELETE)

---

### 12. 구성 변경을 어떻게 처리하나요?
> 🗣️ Q) 구성 변경을 처리하기 위한 다양한 전략에는 무엇이 있으며, ViewModel은 이러한 이벤트 중 UI 관련 데이터를 어떻게 보존하는 데 도움이 되나요?

구성 변경을 효과적으로 처리하기 위한 전략:

1. **UI 상태 저장 및 복원**  
   onSaveInstanceState() 및 onRestoreInstanceState() 메서드를 구현하여 액티비티가 재생성될 때 UI 상태를 보존하고 복원할 수 있습니다. 이를 통해 사용자가 구성 변경 이후에도 동일한 상태로 돌아올 수 있게 합니다.

2. **Jetpack ViewModel 사용**  
   ViewModel 클래스를 활용하면 구성 변경에도 생존하는 UI 관련 데이터를 저장할 수 있습니다. ViewModel 객체는 액티비티 재생성 이후에도 유지되므로 구성 변경 중 데이터 관리를 위한 이상적인 수단입니다.

3. **구성 변경을 수동으로 처리**  
   특정 구성 변경 시 리소스를 업데이트할 필요가 없고, 액티비티 재시작을 피하고 싶다면 AndroidManifest.xml에 android:configChanges 속성을 선언하여 해당 구성 변경을 직접 처리할 수 있습니다. 그런 다음 onConfigurationChanged() 메서드를 오버라이드하여 수동으로 처리합니다.

4. **Jetpack Compose의 rememberSaveable 활용**  
   Jetpack Compose에서는 rememberSaveable을 사용해 구성 변경 시 UI 상태를 저장할 수 있습니다. 이는 onSaveInstanceState()와 유사하지만 Compose에 특화된 방식으로, 컴포저블의 상태를 일관되게 유지하는 데 도움을 줍니다. 이 내용은 **Chapter 1: Jetpack Compose Interview Questions**에서 더 자세히 다룰 예정입니다.  
<br>

> 🗣️ Q) android:configChanges 속성은 AndroidManifest에서 액티비티 생명주기에 어떤 영향을 미치며, 액티비티 재생성 대신 onConfigurationChanged()를 사용해야 하는 상황은 어떤 경우인가요?

AndroidManifest.xml에서 android:configChanges 속성을 선언하면, 시스템은 액티비티를 재생성하지 않고 onConfigurationChanged() 메서드만 호출합니다.

onConfigurationChanged()를 사용하는 것이 적절한 상황:
- 빠른 구성 변경 대응이 필요한 경우
- 커스텀 UI 동기화가 중요한 경우
- 리소스 교체가 필요 없는 경우
- 다크모드, 폰트 크기 변경 등의 대응을 앱에서 직접 제어하고 싶은 경우
- 시스템 기본 동작 대신 개발자가 구성 변경을 정교하게 제어하고 싶은 경우

---

### 13. 안드로이드는 메모리를 어떻게 관리하며, 메모리 누수를 방지하려면 어떻게 해야 하나요?
> 🗣️ Q) 애플리케이션에서 메모리 누수가 발생하는 일반적인 원인은 무엇이며, 이를 방지하기 위해 개발자가 할 수 있는 방법은 무엇인가요?

원인:  
메모리 누수는 애플리케이션이 더 이상 필요하지 않은 객체에 대한 참조를 계속 유지할 때 발생한다.  
일반적인 원인으로는 잘못된 생명주기 관리, static 참조, context에 대한 장시간 참조 유지 등이 있다.

예방하기 위한 방법:
1. **생명주기 인식 컴포넌트 사용**  
   ViewModel, Flow의 collectAsStateWithLifecycle, 또는 LiveData와 같은 생명주기 인식 컴포넌트를 활용하세요. 이들은 관련 생명주기가 종료되거나 특정 상태로 전환될 때 자동으로 자원을 정리합니다.
2. **Context 참조 주의**  
   Activity나 Context를 static 필드나 싱글톤 객체에 보관하지 마세요. 필요 시 ApplicationContext를 사용하면, 이는 Activity나 Fragment의 생명주기에 종속되지 않아 안전합니다.
3. **리스너와 콜백 해제**  
   리스너, 옵저버, 콜백 등은 반드시 적절한 생명주기 메서드에서 해제해야 합니다. 예를 들어, BroadcastReceiver는 onPause()나 onStop()에서 해제하세요.
4. **WeakReference 사용**  
   중요하지 않은 객체에 대해서는 WeakReference를 사용하세요. 이로 인해 메모리가 부족할 경우 가비지 컬렉터가 해당 객체를 안전하게 회수할 수 있습니다.
5. **메모리 누수 탐지 도구 활용**  
   개발 중에는 [LeakCanary](https://square.github.io/leakcanary/)와 같은 도구를 사용해 누수를 감지하고 해결하세요. 또한, Android Studio의 Memory Profiler를 사용하면 누수나 메모리 증가 현상 등을 시각적으로 분석할 수 있습니다.
6. **View에 대한 static 참조 금지**  
   View를 static 필드에 저장하지 마세요. 이는 Activity의 Context를 참조하게 되어 메모리 누수로 이어질 수 있습니다.
7. **리소스 해제 명시적으로 수행**  
   파일 스트림, 커서(Cursor), 데이터베이스 연결 등의 리소스는 사용이 끝나면 반드시 닫아야 합니다. 예를 들어, DB 쿼리 후에는 Cursor를 반드시 닫아야 합니다.
8. **Fragment 및 Activity 사용 시 주의**  
   Fragment를 과도하게 사용하거나 서로 잘못된 방식으로 참조하지 않도록 주의하세요. onDestroyView()나 onDetach()에서 Fragment 관련 참조를 정리해야 합니다.  
<br>

> 🗣️ Q) 안드로이드의 가비지 컬렉션 메커니즘은 어떻게 작동하며, 개발자가 애플리케이션 내 메모리 누수를 탐지하고 수정하기 위해 사용할 수 있는 도구는 무엇인가요?

작동 방식:  
- 객체 참조 추적: GC는 현재 애플리케이션 내에서 더 이상 참조되지 않는 객체를 탐지한다.  
- Heap 정리: 참조가 끊긴 객체는 GC에 의해 heap 메모리에서 제거되어, 새로운 객체가 생성될 수 있는 공간을 확보한다.  
- GC 발생 시점: GC는 주기적이거나 메모리 부족 등 특정 조건에서 자동으로 발생합니다. ART에서는 앱의 성능을 고려해 GC 지연시간을 최소화하도록 최적화되어 있다.  

하지만 GC가 객체를 회수하려면 개발자가 참조를 명확히 끊어줘야 하므로, 메모리 누수는 GC로 자동 해결되지 않는다.

도구:  
LeakCanary, Memory Profiler 등이 있다.

---

### 14. ANR(Application Not Responding) 오류의 주요 원인은 무엇이며, 이를 방지하려면 어떻게 해야 하나요?
> 🗣️ Q) ANR을 감지하고 진단하여 앱 성능을 개선하려면 어떻게 해야 할까요?

ANR을 진단하려면 traces.txt, Android Profiler, StrictMode, Firebase Crashlytics 같은 도구들을 적극 활용해야 한다.  
이러한 정보를 통해 어떤 작업이 메인 스레드를 차단하고 있는지를 정확히 파악하고, 해당 로직을 비동기 처리나 최적화로 개선하면 ANR을 줄이고 앱의 성능을 향상시킬 수 있다.

---

### 15. 딥 링크는 어떻게 처리하나요?
> 🗣️ Q) Android에서 딥 링크를 어떻게 테스트할 수 있으며, 다양한 기기와 시나리오에서 올바르게 작동하는지 확인하기 위한 일반적인 디버깅 기법은 무엇인가요?

**ADB 명령어로 테스트:**  
adb shell 명령어를 사용해 딥 링크를 시뮬레이션할 수 있다.
```bash
adb shell am start -a android.intent.action.VIEW \
-d "https://example.com/deepLink?id=123" \
com.example.myapp
```
이 명령은 실제 외부 URL을 클릭한 것처럼 앱을 실행하여 딥 링크 처리를 검증할 수 있게 한다.

---

### 16. 태스크(Task)와 백 스택(Back Stack)이란?
> 🗣️ Q) singleTask와 singleInstance 실행 모드의 차이점은 무엇이며, 각각 어떤 상황에서 사용하는 것이 좋을까요?

singleTask:  
- 태스크 내에 해당 액티비티의 인스턴스는 단 하나만 존재할 수 있다.  
- 주로 앱의 진입점 역할을 하는 액티비티에 유용하다.

singleInstance:  
- singleTask 와 유사하지만, 이 모드는 해당 액티비티를 **독립적인 태스크 안에 배치**한다. 이 태스크에는 **다른 액티비티가 포함될 수 없으며**, 오직 이 액티비티만 존재한다.
- 완전히 독립적인 작업 흐름을 원할 때 사용됩니다.  
<br>

> 🗣️ Q) 액티비티 실행 모드에는 어떤 것들이 있으며, 각각이 태스크와 백 스택 동작에 어떤 영향을 미치나요?

1. **standard**:  
   기본 실행 모드입니다. 액티비티가 실행될 때마다 항상 새로운 인스턴스가 생성되어 백 스택에 추가된다.  이미 같은 액티비티 인스턴스가 존재하더라도 새로 생성됩니다.
2. **singleTop**:  
   이미 백 스택의 최상단에 동일한 액티비티 인스턴스가 존재한다면, 새로운 인스턴스를 생성하지 않고, 기존 인스턴스가 onNewIntent() 메서드를 통해 인텐트를 처리합니다.
3. **singleTask**:  
   태스크 내에 해당 액티비티의 인스턴스는 단 하나만 존재할 수 있다.  
   이미 존재한다면 해당 인스턴스를 앞으로 가져오고, onNewIntent() 가 호출된다.  
   주로 앱의 진입점 역할을 하는 액티비티에 유용합니다.
4. **singleInstance**:  
   singleTask 와 유사하지만, 이 모드는 해당 액티비티를 독립적인 태스크 안에 배치한다.  
   이 태스크에는 다른 액티비티가 포함될 수 없으며, 오직 이 액티비티만 존재한다.  
   완전히 독립적인 작업 흐름을 원할 때 사용된다.

---

### 17. Bundle의 목적은 무엇인가요?
> 🗣️ Q) onSaveInstanceState()는 구성 변경 중 UI 상태를 보존하기 위해 어떻게 Bundle을 사용하며, Bundle에는 어떤 종류의 데이터를 저장할 수 있나요?

onSaveInstanceState()는 화면 회전 등으로 인해 액티비티가 일시적으로 종료될 때, UI 상태를 임시로 저장하기 위한 메서드로, 이 메서드에서 전달받은 Bundle 객체에 사용자의 입력값, 스크롤 위치 등 일시적인 UI 데이터를 put 메서드를 통해 저장한다. 
이후 액티비티가 다시 생성될 때 onRestoreInstanceState() 또는 onCreate()의 savedInstanceState 매개변수를 통해 해당 데이터를 복원할 수 있다.  
<br>

**Bundle에는 다음과 같은 데이터를 저장할 수 있다:**
- 기본 자료형: int, float, boolean, long, 등
- 문자열: String
- 배열: int[], String[] 등
- Serializable 또는 Parcelable을 구현한 객체
- 또 다른 Bundle 객체

---

### 18. 액티비티나 프래그먼트 간 데이터를 어떻게 전달하나요?
> 🗣️ Q) 동일한 액티비티 내 프래그먼트 간 통신에서 Shared ViewModel은 어떻게 동작하며, Bundle이나 직접적인 프래그먼트 트랜잭션 방식보다 어떤 장점이 있나요?

**동작:**  
Shared ViewModel은 동일한 액티비티에 소속된 프래그먼트들이 하나의 ViewModel 인스턴스를 공유하도록 함으로써 데이터를 주고받을 수 있도록 한다.

**장점:**  
Bundle이나 직접적인 프래그먼트 간 참조보다 결합도가 낮고, 데이터 공유가 명확하며, 코드가 더 깔끔해진다.

---

### 19. 구성 변경이 발생하면 액티비티는 어떻게 되나요?
> 🗣️ Q) 구성 변경으로 인해 액티비티가 재생성될 때 데이터 손실을 방지하려면 어떻게 해야 하며, 일시적인 상태와 지속적인 상태는 각각 어떤 방식으로 처리해야 할까요?

1. 일시적인 상태 (Transient UI State)  
   화면 회전 등으로 인해 사라질 수 있는 입력값, 스크롤 위치, 선택된 항목 등은 onSaveInstanceState()를 사용해 Bundle 객체에 저장하고, onCreate() 또는 onRestoreInstanceState()에서 복원한다.  
<br>
2. 지속적인 상태 (Persistent or Non-UI State)  
      네트워크 응답 결과나 사용자 세션 등 화면과 직접 연결되지 않는 데이터는 ViewModel을 활용해 구성 변경과 무관하게 상태를 유지할 수 있다. ViewModel은 액티비티가 재생성되더라도 유지된다.

---

### 20. ActivityManager란 무엇인가요?
> 🗣️ Q) ActivityManager.getMemoryInfo()를 앱 성능 최적화에 어떻게 활용할 수 있으며, 시스템이 저메모리 상태에 진입했을 때 개발자가 취해야 할 조치는 무엇인가요?

**활용 방안:**
- 앱이 백그라운드에서 많은 메모리를 사용하는 경우, lowMemory == true 상태를 감지해 불필요한 캐시나 리소스를 해제함으로써 앱이 강제 종료되는 것을 방지할 수 있다.
- 대용량 이미지, 미디어 파일, 데이터 객체 등의 로딩 시, 메모리 상태를 확인하고 조건부로 로딩을 조절할 수 있다.
- 메모리 상태에 따라 UI 애니메이션, 효과 등 리소스 소비가 많은 기능을 제한할 수도 있다.  
<br>

**저메모리 상태에서 개발자가 취할 수 있는 조치:**
- ComponentCallbacks2.onTrimMemory() 콜백을 활용해 단계별 메모리 해제를 구현한다.
- 메모리 집약적인 작업(예: Glide, Bitmap 처리 등)을 일시 중지하거나 해제한다.
- 사용하지 않는 리소스와 객체 참조를 해제하고, System.gc() 호출은 피하면서도 자연스러운 GC 유도 전략을 고려한다.
- 필요한 경우 사용자에게 기능 제한이나 앱 재시작을 안내한다.

---

### 21. SparseArray를 사용하는 이점은 무엇인가요?
> 🗣️ Q) 어떤 상황에서 일반 HashMap 대신 SparseArray를 사용하는 것이 더 적절하며, 성능과 사용성 측면에서의 트레이드오프는 무엇인가요?

더 적절한 경우:
- 정수형 키만 사용하는 경우
- 데이터셋 크기가 작거나 중간 정도인 경우
- Android 환경에서 메모리 절약이 중요한 경우
- UI 요소(View ID 등)를 객체에 매핑해야 하는 경우

이러한 상황에서는 SparseArray가 자동 박싱을 피하고 내부적으로 객체 생성을 줄이기 때문에 메모리 사용량이 훨씬 적고 더 가볍다.  
<br>

성능과 사용성 측면에서의 트레이드오프:
- 매우 큰 데이터셋에서는 SparseArray가 이진 탐색 기반으로 동작하므로, HashMap의 해시 기반 검색보다 느릴 수 있다.(성능) 
- SparseArray는 정수 키만 허용하기 때문에, 다양한 타입의 키를 써야 하는 일반적인 Map 용도에는 적합하지 않다.(사용성)

---

### 22. 런타임 권한은 어떻게 처리하나요?
> 🗣️ Q) Android의 런타임 권한 시스템은 어떻게 사용자 프라이버시를 향상시키며, 앱이 민감한 권한을 요청하기 전에 어떤 절차를 따라야 하나요?

Android의 런타임 권한 시스템은 앱이 실제로 해당 기능을 사용할 시점에만 권한을 요청하도록 하여, 사용자가 불필요한 정보 접근을 사전에 차단할 수 있게 한다.  
이를 통해 사용자는 자신의 민감한 정보(위치, 카메라, 마이크 등)에 대한 제어권을 직접 행사할 수 있어 프라이버시가 크게 향상된다.

**앱이 민감한 권한을 요청하기 전에는 다음과 같은 절차를 따라야 한다:**
1. AndroidManifest.xml에 권한 선언
2. ContextCompat.checkSelfPermission()을 통해 권한 상태 확인
3. shouldShowRequestPermissionRationale()을 통해 설명이 필요한 상황인지 판단
4. 사용자에게 권한 요청 이유를 명확히 설명 (UI로 rationale 제공)
5. ActivityResultLauncher 등을 이용해 권한 요청
6. 거부되었을 경우 기능 제한 안내 및 설정 이동 유도(필요 시)

---

### 23. Looper, Handler, HandlerThread의 역할은 무엇인가요?
> 🗣️ Q) Handler는 Looper와 어떻게 함께 작동하여 스레드 간 통신을 가능하게 하나요? 그리고 Handler를 사용하는 일반적인 사례는 무엇인가요?


> 🗣️ Q) HandlerThread란 무엇이며, Looper.prepare()를 사용해 수동으로 스레드를 생성하는 것에 비해 어떤 점에서 백그라운드 스레드 관리를 단순하게 만들어 주나요?


---

### 24. 예외는 어떻게 추적하나요?
> 🗣️ Q) 개발 환경에서는 Logcat을 사용해 예외를 디버깅하고, 운영 환경에서는 Firebase Crashlytics 같은 도구를 사용하는 것의 주요 차이점은 무엇인가요? 각각의 경우에서 예외를 어떻게 해결하나요?

**Logcat (개발 환경)**:   
예외 발생 시 IDE에서 실시간으로 로그와 변수 상태를 확인하며 **즉각적인 디버깅과 수정**이 가능하다.

**Firebase Crashlytics (운영 환경)**:  
사용자 기기에서 발생한 예외를 자동 수집해 **재현이 어려운 문제를 분석**하고 **업데이트로 해결**할 수 있다.  

**주요 차이점**:  
Logcat은 실시간·개발 중심이고, Crashlytics는 배포 후 모니터링 중심이다.  

**예외 해결 방법**:  
Logcat은 브레이크포인트와 로그로, Crashlytics는 리포트를 바탕으로 로컬에서 재현 후 수정한다.  

---

### 25. 빌드 변형(Build Variants)과 플레이버(Flavors)는 무엇인가요?
> 🗣️ Q) 빌드 타입과 제품 플레이버의 차이점은 무엇이며, 이 둘은 어떻게 결합되어 빌드 변형을 생성하나요?

빌드 타입(build types): 앱이 어떻게 빌드되는지를 정의한다. (예: debug vs release).  
제품 플레이버(product flavors): 앱의 변형을 정의한다. (예: free vs paid).

이 둘을 결합하면 다양한 상황에 맞는 맞춤형 앱 빌드를 자동화하고 효율적으로 관리할 수 있다.  
- `freeDebug`
- `freeRelease`
- `paidDebug`
- `paidRelease`

---

### 26. 접근성을 어떻게 보장하나요?
> 🗣️ Q) 동적 글꼴 크기를 지원하기 위한 모범 사례에는 무엇이 있으며, 텍스트 크기에 dp 대신 sp 단위를 사용하는 것이 선호되는 이유는 무엇인가요?



> 🗣️ Q) 보조 기술에 의존하는 사용자를 위해 적절한 포커스 관리와 탐색을 개발자가 어떻게 보장할 수 있으며, 접근성 문제를 테스트하는 데 도움이 되는 도구에는 어떤 것들이 있나요?


---

### 27. 안드로이드 파일 시스템이란 무엇인가요?
> 🗣️ Q) 안드로이드는 파일 시스템에서 보안과 권한을 어떻게 적용하며, 앱들이 서로의 개인 데이터를 접근하지 못하게 하는 메커니즘은 무엇인가요?

안드로이드 파일 시스템은 엄격한 권한 모델을 적용한다:

- **앱 전용 데이터 (Private App Data)**: 앱의 내부 저장소에 저장된 파일은 해당 앱만 접근 가능하며, 완전히 비공개다.
- **공유 파일 (Shared Files)**: 앱 간 파일 공유가 필요한 경우, 외부 저장소나 적절한 권한이 설정된 콘텐츠 제공자(Content Provider)를 통해 공유할 수 있다.
- **스코프 저장소 (Scoped Storage)**: 안드로이드 10에서 도입된 기능으로, 공유 저장소에 대한 직접 접근을 제한하며, 앱은 MediaStore 또는 SAF(Storage Access Framework) API를 통해 파일에 접근해야 한다.

이러한 메커니즘을 통해 안드로이드는 앱 간 격리된 저장 환경을 유지하며, 앱이 다른 앱의 개인 데이터를 임의로 접근하지 못하도록 시스템 수준에서 보안이 강화되어 있다.

---

### 28. Android Runtime(ART), Dalvik, Dex 컴파일러란?
> 🗣️ Q) ART의 AOT(사전 컴파일)는 Dalvik의 JIT(즉시 컴파일)과 어떻게 다르며, 이 차이가 앱 시작 시간과 CPU 사용량에 어떤 영향을 미치나요?

**Dalvik (JIT: Just-in-Time)**
- 앱 실행 중 실시간으로 바이트코드를 기계어로 변환한다.
- 실행 시 매번 변환이 이루어지므로 런타임 시점에 CPU 부하가 발생한다.
- 설치는 빠르지만, 앱을 실행할 때마다 컴파일 비용이 발생한다.

**ART (AOT: Ahead-of-Time)**
- 앱 설치 시점에 바이트코드를 미리 기계어로 변환한.
- 다행 중 추가 컴파일이 필요 없으므로 앱 시작 속도가 빠르고 CPU 부담이 적다.
- 초기 설치 시간과 설치 시 용량은 증가할 수 있다.

앱 시작과 CPU 사용량에 미치는 영향:

|  | Dalvik (JIT) | ART (AOT) |
| - | --- | --- |
| **앱 시작 시간** | 느림 (실시간 컴파일 필요) | 빠름 (미리 컴파일된 코드 사용) |
| **CPU 사용량** | 높음 (실행 중 변환 작업 수행) | 낮음 (변환 작업이 사전에 완료됨) |

`ART의 AOT 방식`: 앱을 미리 컴파일해두기 때문에 앱 실행 속도가 빨라지고, 런타임 시 CPU 사용량이 줄어든다.    
`Dalvik의 JIT 방식`: 앱 설치는 빠르지만, 실행 시 성능 오버헤드가 발생하여 사용자 경험이 저하될 수 있다.
---

### 29. APK 파일과 AAB 파일의 차이점은 무엇인가요?

> 🗣️ Q) AAB 형식은 다양한 기기 구성에 대해 앱 배포를 어떻게 최적화하며, 기존의 APK 배포 방식에 비해 어떤 이점을 제공하나요?

기기 맞춤형 APK 생성 방식으로 최적화 한다.  
개발자가 AAB 파일을 Google Play에 업로드하면, Google Play는 사용자의 기기 사양(예: 화면 크기, 언어, CPU 아키텍처 등)을 분석하여 해당 기기에 딱 맞는 리소스와 코드만 포함된 APK 를 자동으로 생성해 배포한다.  

기존의 APK 배포 방식에 비해 제공하는 이점:
1. **앱 크기 감소**
    - APK는 모든 기기 구성을 포함해야 하기 때문에 불필요한 리소스도 함께 포함되어 파일이 크고 비효율적이다.
    - AAB는 필요한 리소스만 포함된 APK를 생성하므로 앱 크기를 줄이고 다운로드 속도 및 설치 속도를 개선할 수 있다.
2. **자동화된 구성 관리**
    - APK 방식에서는 다양한 화면 밀도나 CPU 아키텍처에 맞는 리소스를 개발자가 직접 관리해야 했다.
    - AAB는 이러한 구성 관리를 Google Play에서 자동으로 처리해주므로 개발자의 유지보수 부담이 줄어든다.
3. **더 나은 사용자 경험**
    - 최적화된 APK 덕분에 설치 속도가 빨라지고 저장 공간도 절약되며, 사용자는 자신의 기기에 꼭 맞는 가볍고 빠른 앱을 사용할 수 있다.
---

### 30. R8 최적화란 무엇인가요?
> 🗣️ Q) R8 최적화는 앱의 성능을 어떻게 개선하고 APK/AAB 크기를 어떻게 줄이나요?

R8은 빌드 단계에서 다음과 같은 최적화를 통해 앱의 성능을 개선하고 크기를 줄인다:
1. 코드 축소(Code Shrinking)
   - 사용되지 않는 클래스, 메서드, 필드 등을 제거하여 불필요한 코드가 포함되지 않도록 한다.
   - 이를 통해 APK/AAB의 크기가 줄어듭니다.

2. 리소스 최적화(Resource Optimization)
    - 사용되지 않는 레이아웃, 이미지, 문자열 등의 리소스를 제거하여 전체 앱 용량을 감소시킨다.

3. 코드 최적화(Optimization)
   - 다음와 같은 방식으로 실행 속도를 개선하고 CPU 사용량을 줄인다.
     - 메서드 인라인(inlining)
     - 중복 코드 병합 
     - 불필요한 연산 제거

4. 상수 전파(Constant Folding)
   - 상수 값 계산을 빌드 타임에 미리 수행함으로써 런타임 계산을 줄이고 퍼포먼스를 높인다.

<br>

> 🗣️ Q) R8은 ProGuard와 어떻게 다르며, 어떤 장점을 제공하나요?

R8은 ProGuard를 대체하기 위해 만들어진 도구로, 다음과 같은 차이점과 장점이 있다:

| 항목    | ProGuard                | R8                         |
|-------|-------------------------|----------------------------|
| 통합    | 별도 설치 필요                | Android 빌드 시스템에 기본 내장      |
| 수행 방식 | 단계별 처리 (축소 → 최적화 → 난독화) | 단일 패스로 처리하여 더 빠름           |
| 속도    | 상대적으로 느림                | 더 빠르고 효율적                  |
| 지원 기능 | 축소, 난독화 중심              | 축소, 최적화, 난독화, 리소스 제거까지 포괄적 |
| 보안성   | 난독화만 지원                 | 더 정교한 난독화 제공               |

**R8의 주요 장점:**
- 빌드 속도 향상 (단일 패스 처리)
- APK/AAB 크기 더 감소 
- 보다 정밀한 최적화 및 난독화 
- Android Gradle Plugin과의 완전한 통합으로 사용 편의성 향상

➡ 따라서 R8은 ProGuard보다 더 강력하고 빠르며, 설정이 간단하고 효과적인 최적화 도구다.

---

### 31. 애플리케이션 크기를 줄이려면 어떻게 해야 하나요?
> 🗣️ Q) 앱에 고해상도 이미지가 많아 APK/AAB 용량이 크게 증가했습니다. 시각적 품질을 유지하면서 이미지 리소스를 어떻게 최적화할 수 있으며, 최대한 효율적인 포맷은 무엇인가요?

**WebP 포맷:**  
WebP는 PNG보다 최대 25~35%, JPEG보다 최대 30% 이상 더 효율적인 압축률을 제공한다.  
손실(lossy) 및 무손실(lossless) 압축 모두 지원하며, 투명도(alpha channel)도 처리 가능하므로 PNG를 대체할 수 있다.  
<br>

> 🗣️ Q) 애플리케이션에는 다양한 기능이 있지만, 일부 기능은 대부분 사용자에게 거의 사용되지 않습니다. 초기 앱 크기를 줄이면서도 이러한 기능을 필요 시 제공할 수 있도록 하려면 어떻게 구현하시겠습니까?

**Dynamic Feature Module(동적 기능 모듈)을 활용한다.**  
이 기능은 Google Play의 온디맨드 다운로드 기능과 연계되어, 앱의 초기 설치 크기를 줄이고 필요한 기능만 나중에 설치할 수 있게 해준다.

---

### 32. 안드로이드 애플리케이션에서 프로세스란 무엇이며, 안드로이드 운영체제는 이를 어떻게 관리하나요?
> 🗣️ Q) 서로 다른 안드로이드 구성 요소들이 각기 다른 프로세스에서 실행되어야 하는 애플리케이션을 개발 중입니다. 이를 AndroidManifest에서 어떻게 설정하겠으며, 여러 프로세스를 사용하는데 따른 잠재적인 단점은 무엇인가요?

AndroidManifest.xml 파일에서 각 구성 요소에 android:process 속성을 지정한다.
```xml
<application
    android:name=".MyApplication"
    android:label="@string/app_name">

    <activity
        android:name=".MainActivity"
        android:process=":main_process" />

    <service
        android:name=".MyService"
        android:process=":background_service" />

    <receiver
        android:name=".MyReceiver"
        android:process=":receiver_process" />

    <provider
        android:name=".MyContentProvider"
        android:authorities="com.example.provider"
        android:process=":provider_process" />

</application>
```

**여러 프로세스를 사용하는데 따른 잠재적인 단점:**
- **메모리 소비 증가**
    - 각 프로세스는 독립된 메모리 공간을 사용하므로, 전체 앱의 메모리 사용량이 증가한다.
    - 이는 저사양 기기에서 앱이 강제 종료되는 원인이 될 수 있다.
- **IPC(프로세스 간 통신)의 복잡성**
    - 서로 다른 프로세스 간에 데이터를 주고받기 위해 `AIDL`, `Binder`, `Messenger` 등을 사용해야 하며, 이는 개발과 디버깅을 어렵게 만든다.
- **데이터 공유 제한**
    - 동일한 프로세스가 아니면 메모리 공간을 공유하지 않기 때문에, 전역 변수나 객체를 직접 공유할 수 없다.
    - `SharedPreferences`, 데이터베이스, `ContentProvider` 등을 통한 간접 공유가 필요합니다.
- **앱 생명주기 관리 복잡화**
    - 프로세스가 독립적으로 관리되므로, 한 구성 요소가 죽더라도 다른 프로세스는 살아있을 수 있고, 전체 애플리케이션의 상태 추적이 어려워질 수 있다.
- **성능 저하 가능성**
    - 프로세스 간 전환이나 통신이 발생할 때, 컨텍스트 스위칭 등으로 인한 오버헤드가 발생할 수 있다.  
<br>

> 🗣️ Q) 안드로이드는 메모리가 부족할 때 종료할 프로세스를 결정하기 위해 우선순위 기반의 프로세스 관리 시스템을 사용합니다. 시스템이 프로세스의 우선순위를 어떻게 판단하는지, 중요한 프로세스가 종료되지 않도록 하기 위해 개발자가 따라야 할 전략은 무엇인지 설명해보세요.

안드로이드 시스템은 각 프로세스의 현재 상태와 중요도를 기준으로 우선순위를 매기고, 낮은 우선순위부터 종료하여 메모리를 확보한다.  

**안드로이드의 프로세스 우선순위 판단 기준:**
1. **포그라운드 프로세스 (Foreground Process)**
    - 사용자와 직접 상호작용 중인 프로세스 (예: 화면에 보이는 액티비티)
    - **최우선**, 거의 종료되지 않음
2. **가시 프로세스 (Visible Process)**
    - 사용자에게 보이지만 포커스를 가지지 않는 프로세스 (예: 다이얼로그 뒤의 액티비티)
    - 포그라운드 다음으로 높은 우선순위
3. **서비스 프로세스 (Service Process)**
    - 백그라운드에서 작업 수행 중인 서비스가 있는 프로세스 (예: 음악 재생, 데이터 동기화 등)
    - 가시 프로세스보다 낮음
4. **백그라운드 프로세스 (Background Process)**
    - 사용자와 상호작용하지 않는 상태로 일시 중단된 액티비티 등을 포함한 프로세스
    - 종료 우선순위 높음
5. **캐시된 프로세스 (Cached Process)**
    - 최근에 사용됐지만 현재는 아무 구성 요소도 실행하지 않는 프로세스
    - **가장 낮은 우선순위**, 메모리가 부족할 경우 가장 먼저 종료됨  
<br>

**중요한 프로세스가 종료되지 않도록 하기 위한 개발자 전략:**
1. **필요한 경우 포그라운드 서비스 사용**
    - 중요한 백그라운드 작업(예: 음악 재생, 위치 추적 등)은 `startForegroundService()`를 사용하여 포그라운드 서비스로 승격
    - 포그라운드 서비스는 알림을 필요로 하며, 시스템이 종료하지 않음
2. **불필요한 리소스 해제 및 메모리 최적화**
    - 사용하지 않는 객체는 명시적으로 정리하고, 이미지·캐시 등은 최소한으로 유지
    - `onTrimMemory()`나 `onLowMemory()` 콜백을 활용해 메모리 부족 시 자원 해제
3. **앱 상태에 맞는 생명주기 처리 구현**
    - `Activity`, `Service`, `ViewModel` 등의 생명주기를 정확하게 관리하여 유휴 리소스가 오래 남아있지 않도록 함
4. **프로세스를 불필요하게 분리하지 않기**
    - 프로세스가 많아질수록 시스템 자원 사용량이 증가하며, 우선순위가 낮은 보조 프로세스는 종료될 가능성이 높음
5. **지속적인 사용자와의 상호작용 유지**
    - 사용자와 상호작용하는 상태(예: 알림, 백그라운드 UI 등)를 유지하면 시스템은 해당 프로세스를 더 오래 유지함
